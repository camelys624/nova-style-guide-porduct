<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 4.11.0"/><style data-href="/styles.5da8afc12734bfddb04a.css" data-identity="gatsby-global-css">/*!
  Theme: Dracula
  Author: Mike Barkmin (http://github.com/mikebarkmin) based on Dracula Theme (http://github.com/dracula)
  License: ~ MIT (or more permissive) [via base16-schemes-source]
  Maintainer: @highlightjs/core-team
  Version: 2021.09.0
*/pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{background:#282936;color:#e9e9f4}.hljs ::selection,.hljs::selection{background-color:#4d4f68;color:#e9e9f4}.hljs-comment{color:#626483}.hljs-tag{color:#62d6e8}.hljs-operator,.hljs-punctuation,.hljs-subst{color:#e9e9f4}.hljs-operator{opacity:.7}.hljs-bullet,.hljs-deletion,.hljs-name,.hljs-selector-tag,.hljs-template-variable,.hljs-variable{color:#ea51b2}.hljs-attr,.hljs-link,.hljs-literal,.hljs-number,.hljs-symbol,.hljs-variable.constant_{color:#b45bcf}.hljs-class .hljs-title,.hljs-strong,.hljs-title,.hljs-title.class_{color:#00f769}.hljs-strong{font-weight:700}.hljs-addition,.hljs-code,.hljs-string,.hljs-title.class_.inherited__{color:#ebff87}.hljs-built_in,.hljs-doctag,.hljs-keyword.hljs-atrule,.hljs-quote,.hljs-regexp{color:#a1efe4}.hljs-attribute,.hljs-function .hljs-title,.hljs-section,.hljs-title.function_,.ruby .hljs-property{color:#62d6e8}.diff .hljs-meta,.hljs-keyword,.hljs-template-tag,.hljs-type{color:#b45bcf}.hljs-emphasis{color:#b45bcf;font-style:italic}.hljs-meta,.hljs-meta .hljs-keyword,.hljs-meta .hljs-string{color:#00f769}.hljs-meta .hljs-keyword,.hljs-meta-keyword{font-weight:700}:root{--default-color:#212121;--background-color:#fff;--border-color:#f6f6f6;--default-width-1:0.05208vw;--default-width-20:calc(var(--default-width-1)*20);--box-shadow:rgb(0 0 0/6%) 0px calc(var(--default-width-1)*6) calc(var(--default-width-1)*24);--border-radius:calc(var(--default-width-1)*4);--font-size:calc(var(--default-width-1)*14);--large-font-size:calc(var(--default-width-1)*16);font-size:var(--font-size)}body{margin:0}code{background-color:#e3e3e3;border-radius:5px;padding:3px 5px}blockquote{border-left:.25em solid #d0d7de;margin:0;padding:0 1em}img{max-width:100%}.hljs{font-family:Fira Code}.index-module--card--FvfCF{background-color:var(--background-color);border:var(--default-width-1) solid #e3e3e3;color:var(--default-color);margin:0 calc(var(--default-width-20)/2);padding:0 var(--default-width-20);text-decoration:none}.index-module--card--FvfCF:hover{box-shadow:var(--box-shadow)}.index-module--type-card__title--fwrmv{border-bottom:solid var(--default-width-1) var(--border-color);height:calc(var(--default-width-20)*3);line-height:calc(var(--default-width-20)*3)}.index-module--type-card__content--wul88{display:flex;flex-wrap:wrap}.index-module--header-box--RtnlP{box-shadow:var(--box-shadow);position:fixed;top:0;width:100%}header{align-items:center;background-color:var(--background-color);display:flex;height:calc(var(--default-width-20)*3.5);justify-content:space-between;margin:0 auto;max-width:80rem;padding:0 1.5rem}.index-module--menu--T2tkF,.index-module--sub-menu--kdLk5{display:flex;list-style-type:none;padding:0}.index-module--menu--T2tkF>li{cursor:pointer;display:block;font-size:var(--large-font-size);font-weight:700;height:calc(var(--default-width-20)*3.5);line-height:calc(var(--default-width-20)*3.5);padding:0 var(--default-width-20)}.index-module--menu--T2tkF>li:hover .index-module--sub-menu--kdLk5{display:block}.index-module--sub-menu--kdLk5{background-color:var(--background-color);border-radius:var(--border-radius);box-shadow:var(--box-shadow);display:none;flex-direction:column;position:absolute;width:calc(var(--default-width-20)*6)}.index-module--sub-menu--kdLk5>li{cursor:pointer;height:calc(var(--default-width-20)*2);line-height:calc(var(--default-width-20)*2);padding:0 var(--default-width-20)}:is(.index-module--menu--T2tkF,.index-module--sub-menu--kdLk5) li a,h2>a{color:var(--default-color);display:block;height:100%;text-decoration:none}.index-module--md-content--tPtrw{margin:calc(var(--default-width-20)*4.5) auto 0;max-width:80rem}</style><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><title data-react-helmet="true"></title><link rel="sitemap" type="application/xml" href="/sitemap/sitemap-index.xml"/><link rel="icon" href="/favicon-32x32.png?v=53aa06cf17e4239d0dba6ffd09854e02" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=53aa06cf17e4239d0dba6ffd09854e02"/><link as="script" rel="preload" href="/webpack-runtime-a8b117a0c06915913bd8.js"/><link as="script" rel="preload" href="/framework-40f550404eff6143517a.js"/><link as="script" rel="preload" href="/app-5ff64c5c6731c3d5b165.js"/><link as="script" rel="preload" href="/42c9f84f9645ed5f761b4c6678255cf01342391e-664e7f9e279843ee0ff6.js"/><link as="script" rel="preload" href="/component---src-pages-mdx-slug-tsx-e6b9a5a5ab118c518437.js"/><link as="fetch" rel="preload" href="/page-data/front-guide/language/vue-guide/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2744905544.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><script>(function() { try {
  var mode = localStorage.getItem('theme-ui-color-mode');
  if (!mode) return
  document.documentElement.classList.add('theme-ui-' + mode);
} catch (e) {} })();</script><div id="___gatsby"><style data-emotion="css-global ehhlky">html{color:var(--theme-ui-colors-text);background-color:var(--theme-ui-colors-background);}</style><style data-emotion="css-global 0"></style><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="index-module--header-box--RtnlP"><header><h2><a href="/">Nova Style Guide</a></h2><nav><ul class="index-module--menu--T2tkF"><li><a href="/front-end-page">Front End</a></li><li>Back End</li><li>UI/UX Design</li><li><a href="/blog-page">Blog</a></li><li>Projects<ul class="index-module--sub-menu--kdLk5"><li>Nova</li><li>Hydra</li><li>Asgard</li></ul></li></ul></nav></header></div><main class="index-module--md-content--tPtrw"><h2>Vue guide</h2><p class="css-0">这里是官方的 Vue 特有代码的风格指南。如果在工程中使用 Vue，为了回避错误、小纠结和反模式，该指南是份不错的参考。不过我们也不确信风格指南的所有内容对于所有的团队或工程都是理想的。所以根据过去的经验、周围的技术栈、个人价值观做出有意义的偏差是可取的。</p><p class="css-0">对于其绝大部分，我们也总体上避免就 JavaScript 或 HTML 的本身提出建议。我们不介意你是否使用分号或结尾的逗号。我们不介意你在 HTML attribute 中使用单引号还是双引号。不过当我们发现在 Vue 的情景下有帮助的特定模式时，也会存在例外。</p><blockquote class="css-0"><p class="css-0"><strong class="css-0">不久之后，我们还会提供操作层面的技巧。</strong>有的时候你只需要遵守规则，而我们会尽可能向你展示如何使用 ESLint 及其它自动化程序把操作层面弄得更简单。</p></blockquote><p class="css-0">最终，我们把所有的规则归为了四个大类：</p><h2 class="css-0">规则归类</h2><h3 class="css-0">优先级 A：必要的</h3><p class="css-0">这些规则会帮你规避错误，所以学习并接受它们带来的全部代价吧。这里面可能存在例外，但应该非常少，且只有你同时精通 JavaScript 和 Vue 才可以这样做。</p><h3 class="css-0">优先级 B：强烈推荐</h3><p class="css-0">这些规则能够在绝大多数工程中改善可读性和开发体验。即使你违反了，代码还是能照常运行，但例外应该尽可能少且有合理的理由。</p><h3 class="css-0">优先级 C：推荐</h3><p class="css-0">当存在多个同样好的选项，选任意一个都可以确保一致性。在这些规则里，我们描述了每个选项并建议一个默认的选择。也就是说只要保持一致且理由充分，你可以随意在你的代码库中做出不同的选择。请务必给出一个好的理由！通过接受社区的标准，你将会：</p><ol class="css-0"><li class="css-0">训练你的大脑，以便更容易的处理你在社区遇到的代码；</li><li class="css-0">不做修改就可以直接复制粘贴社区的代码示例；</li><li class="css-0">能够经常招聘到和你编码习惯相同的新人，至少跟 Vue 相关的东西是这样的。</li></ol><h3 class="css-0">优先级 D：谨慎使用</h3><p class="css-0">有些 Vue 特性的存在是为了照顾极端情况或帮助老代码的平稳迁移。当被过度使用时，这些特性会让你的代码难于维护甚至变成 bug 的来源。这些规则是为了给有潜在风险的特性敲个警钟，并说明它们什么时候不应该使用以及为什么。</p><h2 class="css-0">优先级 A 的规则：必要的 (规避错误)</h2><h3 class="css-0">组件名为多个单词<sup data-p="a">必要</sup></h3><p class="css-0"><strong class="css-0">组件名应该始终是多个单词的，根组件 <code class="css-0">App</code> 以及 <code class="css-0">&lt;transition&gt;</code>、<code class="css-0">&lt;component&gt;</code> 之类的 Vue 内置组件除外。</strong></p><p class="css-0">这样做可以避免跟现有的以及未来的 HTML 元素<a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name" class="css-0">相冲突</a>，因为所有的 HTML 元素名称都是单个单词的。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;todo&#x27;, {
  // ...
})
</code></pre><pre class="css-0"><code class="language-js css-0">export default {
  name: &#x27;Todo&#x27;,
  // ...
}
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;todo-item&#x27;, {
  // ...
})
</code></pre><pre class="css-0"><code class="language-js css-0">export default {
  name: &#x27;TodoItem&#x27;,
  // ...
}
</code></pre><h3 class="css-0">组件数据<sup data-p="a">必要</sup></h3><p class="css-0"><strong class="css-0">组件的 <code class="css-0">data</code> 必须是一个函数。</strong></p><p class="css-0">当在组件中使用 <code class="css-0">data</code> property 的时候 (除了 <code class="css-0">new Vue</code> 外的任何地方)，它的值必须是返回一个对象的函数。</p><h4 class="css-0">详解</h4><p class="css-0">当 <code class="css-0">data</code> 的值是一个对象时，它会在这个组件的所有实例之间共享。想象一下，假如一个 <code class="css-0">TodoList</code> 组件的数据是这样的：</p><pre class="css-0"><code class="language-js css-0">data: {
  listTitle: &#x27;&#x27;,
  todos: []
}
</code></pre><p class="css-0">我们可能希望重用这个组件，允许用户维护多个列表 (比如分为购物、心愿单、日常事务等)。这时就会产生问题。因为每个组件的实例都引用了相同的数据对象，更改其中一个列表的标题就会改变其它每一个列表的标题。增删改一个待办事项的时候也是如此。</p><p class="css-0">取而代之的是，我们希望每个组件实例都管理其自己的数据。为了做到这一点，每个实例必须生成一个独立的数据对象。在 JavaScript 中，在一个函数中返回这个对象就可以了：</p><pre class="css-0"><code class="language-js css-0">data: function () {
  return {
    listTitle: &#x27;&#x27;,
    todos: []
  }
}
</code></pre><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;some-comp&#x27;, {
  data: {
    foo: &#x27;bar&#x27;
  }
})
</code></pre><pre class="css-0"><code class="language-js css-0">export default {
  data: {
    foo: &#x27;bar&#x27;
  }
}
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;some-comp&#x27;, {
  data: function () {
    return {
      foo: &#x27;bar&#x27;
    }
  }
})
</code></pre><pre class="css-0"><code class="language-js css-0">// In a .vue file
export default {
  data () {
    return {
      foo: &#x27;bar&#x27;
    }
  }
}
</code></pre><pre class="css-0"><code class="language-js css-0">// 在一个 Vue 的根实例上直接使用对象是可以的，
// 因为只存在一个这样的实例。
new Vue({
  data: {
    foo: &#x27;bar&#x27;
  }
})
</code></pre><h3 class="css-0">Prop 定义<sup data-p="a">必要</sup></h3><p class="css-0"><strong class="css-0">Prop 定义应该尽量详细。</strong></p><p class="css-0">在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。</p><h4 class="css-0">详解</h4><p class="css-0">细致的 <a href="../guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" class="css-0">prop 定义</a>有两个好处：</p><ul class="css-0"><li class="css-0">它们写明了组件的 API，所以很容易看懂组件的用法；</li><li class="css-0">在开发环境下，如果向一个组件提供格式不正确的 prop，Vue 将会告警，以帮助你捕获潜在的错误来源。</li></ul><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">// 这样做只有开发原型系统时可以接受
props: [&#x27;status&#x27;]
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">props: {
  status: String
}
</code></pre><pre class="css-0"><code class="language-js css-0">// 更好的做法！
props: {
  status: {
    type: String,
    required: true,
    validator: function (value) {
      return [
        &#x27;syncing&#x27;,
        &#x27;synced&#x27;,
        &#x27;version-conflict&#x27;,
        &#x27;error&#x27;
      ].indexOf(value) !== -1
    }
  }
}
</code></pre><h3 class="css-0">为 <code class="css-0">v-for</code> 设置键值<sup data-p="a">必要</sup></h3><p class="css-0"><strong class="css-0">总是用 <code class="css-0">key</code> 配合 <code class="css-0">v-for</code>。</strong></p><p class="css-0">在组件上<em class="css-0">总是</em>必须用 <code class="css-0">key</code> 配合 <code class="css-0">v-for</code>，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href="https://bost.ocks.org/mike/constancy/" class="css-0">对象固化 (object constancy)</a>，也是一种好的做法。</p><h4 class="css-0">详解</h4><p class="css-0">假设你有一个待办事项列表：</p><pre class="css-0"><code class="language-js css-0">data: function () {
  return {
    todos: [
      {
        id: 1,
        text: &#x27;学习使用 v-for&#x27;
      },
      {
        id: 2,
        text: &#x27;学习使用 key&#x27;
      }
    ]
  }
}
</code></pre><p class="css-0">然后你把它们按照字母顺序排序。在更新 DOM 的时候，Vue 将会优化渲染把可能的 DOM 变更降到最低。即可能删掉第一个待办事项元素，然后把它重新加回到列表的最末尾。</p><p class="css-0">这里的问题在于，不要删除仍然会留在 DOM 中的元素。比如你想使用 <code class="css-0">&lt;transition-group&gt;</code> 给列表加过渡动画，或想在被渲染元素是 <code class="css-0">&lt;input&gt;</code> 时保持聚焦。在这些情况下，为每一个项目添加一个唯一的键值 (比如 <code class="css-0">:key=&quot;todo.id&quot;</code>) 将会让 Vue 知道如何使行为更容易预测。</p><p class="css-0">根据我们的经验，最好<em class="css-0">始终</em>添加一个唯一的键值，以便你和你的团队永远不必担心这些极端情况。也在少数对性能有严格要求的情况下，为了避免对象固化，你可以刻意做一些非常规的处理。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li v-for=&quot;todo in todos&quot;&gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in todos&quot;
    :key=&quot;todo.id&quot;
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><h3 class="css-0">避免 <code class="css-0">v-if</code> 和 <code class="css-0">v-for</code> 用在一起<sup data-p="a">必要</sup></h3><p class="css-0"><strong class="css-0">永远不要把 <code class="css-0">v-if</code> 和 <code class="css-0">v-for</code> 同时用在同一个元素上。</strong></p><p class="css-0">一般我们在两种常见的情况下会倾向于这样做：</p><ul class="css-0"><li class="css-0"><p class="css-0">为了过滤一个列表中的项目 (比如 <code class="css-0">v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code class="css-0">users</code> 替换为一个计算属性 (比如 <code class="css-0">activeUsers</code>)，让其返回过滤后的列表。</p></li><li class="css-0"><p class="css-0">为了避免渲染本应该被隐藏的列表 (比如 <code class="css-0">v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code class="css-0">v-if</code> 移动至容器元素上 (比如 <code class="css-0">ul</code>、<code class="css-0">ol</code>)。</p></li></ul><h4 class="css-0">详解</h4><p class="css-0">当 Vue 处理指令时，<code class="css-0">v-for</code> 比 <code class="css-0">v-if</code> 具有更高的优先级，所以这个模板：</p><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;user.isActive&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p class="css-0">将会经过如下运算：</p><pre class="css-0"><code class="language-js css-0">this.users.map(function (user) {
  if (user.isActive) {
    return user.name
  }
})
</code></pre><p class="css-0">因此哪怕我们只渲染出一小部分用户的元素，也得在每次重渲染的时候遍历整个列表，不论活跃用户是否发生了变化。</p><p class="css-0">通过将其更换为在如下的一个计算属性上遍历：</p><pre class="css-0"><code class="language-js css-0">computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
      return user.isActive
    })
  }
}
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in activeUsers&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p class="css-0">我们将会获得如下好处：</p><ul class="css-0"><li class="css-0">过滤后的列表<em class="css-0">只</em>会在 <code class="css-0">users</code> 数组发生相关变化时才被重新运算，过滤更高效。</li><li class="css-0">使用 <code class="css-0">v-for=&quot;user in activeUsers&quot;</code> 之后，我们在渲染的时候<em class="css-0">只</em>遍历活跃用户，渲染更高效。</li><li class="css-0">解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。</li></ul><p class="css-0">为了获得同样的好处，我们也可以把：</p><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;shouldShowUsers&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p class="css-0">更新为：</p><pre class="css-0"><code class="language-html css-0">&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p class="css-0">通过将 <code class="css-0">v-if</code> 移动到容器元素，我们不会再对列表中的<em class="css-0">每个</em>用户检查 <code class="css-0">shouldShowUsers</code>。取而代之的是，我们只检查它一次，且不会在 <code class="css-0">shouldShowUsers</code> 为否的时候运算 <code class="css-0">v-for</code>。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;user.isActive&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    v-if=&quot;shouldShowUsers&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;ul&gt;
  &lt;li
    v-for=&quot;user in activeUsers&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;ul v-if=&quot;shouldShowUsers&quot;&gt;
  &lt;li
    v-for=&quot;user in users&quot;
    :key=&quot;user.id&quot;
  &gt;
    {{ user.name }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><h3 class="css-0">为组件样式设置作用域<sup data-p="a">必要</sup></h3><p class="css-0"><strong class="css-0">对于应用来说，顶级 <code class="css-0">App</code> 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。</strong></p><p class="css-0">这条规则只和<a href="../guide/single-file-components.html" class="css-0">单文件组件</a>有关。你<em class="css-0">不一定</em>要使用 <a href="https://vue-loader.vuejs.org/zh-cn/features/scoped-css.html" class="css-0"><code class="css-0">scoped</code> attribute</a>。设置作用域也可以通过 <a href="https://vue-loader.vuejs.org/zh-cn/features/css-modules.html" class="css-0">CSS Modules</a>，那是一个基于 class 的类似 <a href="http://getbem.com/" class="css-0">BEM</a> 的策略，当然你也可以使用其它的库或约定。</p><p class="css-0"><strong class="css-0">不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 <code class="css-0">scoped</code> attribute。</strong></p><p class="css-0">这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。</p><h4 class="css-0">详解</h4><p class="css-0">如果你和其他开发者一起开发一个大型工程，或有时引入三方 HTML/CSS (比如来自 Auth0)，设置一致的作用域会确保你的样式只会运用在它们想要作用的组件上。</p><p class="css-0">不止要使用 <code class="css-0">scoped</code> attribute，使用唯一的 class 名可以帮你确保那些三方库的 CSS 不会运用在你自己的 HTML 上。比如许多工程都使用了 <code class="css-0">button</code>、<code class="css-0">btn</code> 或 <code class="css-0">icon</code> class 名，所以即便你不使用类似 BEM 的策略，添加一个 app 专属或组件专属的前缀 (比如 <code class="css-0">ButtonClose-icon</code>) 也可以提供很多保护。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;template&gt;
  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;style&gt;
.btn-close {
  background-color: red;
}
&lt;/style&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;template&gt;
  &lt;button class=&quot;button button-close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;!-- 使用 `scoped` attribute --&gt;
&lt;style scoped&gt;
.button {
  border: none;
  border-radius: 2px;
}

.button-close {
  background-color: red;
}
&lt;/style&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;template&gt;
  &lt;button :class=&quot;[$style.button, $style.buttonClose]&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;!-- 使用 CSS Modules --&gt;
&lt;style module&gt;
.button {
  border: none;
  border-radius: 2px;
}

.buttonClose {
  background-color: red;
}
&lt;/style&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;template&gt;
  &lt;button class=&quot;c-Button c-Button--close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;!-- 使用 BEM 约定 --&gt;
&lt;style&gt;
.c-Button {
  border: none;
  border-radius: 2px;
}

.c-Button--close {
  background-color: red;
}
&lt;/style&gt;
</code></pre><h3 class="css-0">私有 property 名<sup data-p="a">必要</sup></h3><p class="css-0"><strong class="css-0">使用模块作用域保持不允许外部访问的函数的私有性。如果无法做到这一点，就始终为插件、混入等不考虑作为对外公共 API 的自定义私有 property 使用 <code class="css-0">$_</code> 前缀。并附带一个命名空间以回避和其它作者的冲突 (比如 <code class="css-0">$_yourPluginName_</code>)。</strong></p><h4 class="css-0">详解</h4><p class="css-0">Vue 使用 <code class="css-0">_</code> 前缀来定义其自身的私有 property，所以使用相同的前缀 (比如 <code class="css-0">_update</code>) 有覆写实例 property 的风险。即便你检查确认 Vue 当前版本没有用到这个 property 名，也不能保证和将来的版本没有冲突。</p><p class="css-0">对于 <code class="css-0">$</code> 前缀来说，其在 Vue 生态系统中的目的是暴露给用户的一个特殊的实例 property，所以把它用于<em class="css-0">私有</em> property 并不合适。</p><p class="css-0">不过，我们推荐把这两个前缀结合为 <code class="css-0">$_</code>，作为一个用户定义的私有 property 的约定，以确保不会和 Vue 自身相冲突。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">var myGreatMixin = {
  // ...
  methods: {
    update: function () {
      // ...
    }
  }
}
</code></pre><pre class="css-0"><code class="language-js css-0">var myGreatMixin = {
  // ...
  methods: {
    _update: function () {
      // ...
    }
  }
}
</code></pre><pre class="css-0"><code class="language-js css-0">var myGreatMixin = {
  // ...
  methods: {
    $update: function () {
      // ...
    }
  }
}
</code></pre><pre class="css-0"><code class="language-js css-0">var myGreatMixin = {
  // ...
  methods: {
    $_update: function () {
      // ...
    }
  }
}
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">var myGreatMixin = {
  // ...
  methods: {
    $_myGreatMixin_update: function () {
      // ...
    }
  }
}
</code></pre><pre class="css-0"><code class="language-js css-0">// 甚至更好！
var myGreatMixin = {
  // ...
  methods: {
    publicMethod() {
      // ...
      myPrivateFunction()
    }
  }
}

function myPrivateFunction() {
  // ...
}

export default myGreatMixin
</code></pre><h2 class="css-0">优先级 B 的规则：强烈推荐 (增强可读性)</h2><h3 class="css-0">组件文件<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">只要有能够拼接文件的构建系统，就把每个组件单独分成文件。</strong></p><p class="css-0">当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;TodoList&#x27;, {
  // ...
})

Vue.component(&#x27;TodoItem&#x27;, {
  // ...
})
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="css-0">components/
|- TodoList.js
|- TodoItem.js
</code></pre><pre class="css-0"><code class="css-0">components/
|- TodoList.vue
|- TodoItem.vue
</code></pre><h3 class="css-0">单文件组件文件的大小写<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0"><a href="../guide/single-file-components.html" class="css-0">单文件组件</a>的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</strong></p><p class="css-0">单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="css-0">components/
|- mycomponent.vue
</code></pre><pre class="css-0"><code class="css-0">components/
|- myComponent.vue
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="css-0">components/
|- MyComponent.vue
</code></pre><pre class="css-0"><code class="css-0">components/
|- my-component.vue
</code></pre><h3 class="css-0">基础组件名<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 <code class="css-0">Base</code>、<code class="css-0">App</code> 或 <code class="css-0">V</code>。</strong></p><h4 class="css-0">详解</h4><p class="css-0">这些组件为你的应用奠定了一致的基础样式和行为。它们可能<strong class="css-0">只</strong>包括：</p><ul class="css-0"><li class="css-0">HTML 元素</li><li class="css-0">其它基础组件</li><li class="css-0">第三方 UI 组件库</li></ul><p class="css-0">但是它们<strong class="css-0">绝不会</strong>包括全局状态 (比如来自 Vuex store)。</p><p class="css-0">它们的名字通常包含所包裹元素的名字 (比如 <code class="css-0">BaseButton</code>、<code class="css-0">BaseTable</code>)，除非没有现成的对应功能的元素 (比如 <code class="css-0">BaseIcon</code>)。如果你为特定的上下文构建类似的组件，那它们几乎总会消费这些组件 (比如 <code class="css-0">BaseButton</code> 可能会用在 <code class="css-0">ButtonSubmit</code> 上)。</p><p class="css-0">这样做的几个好处：</p><ul class="css-0"><li class="css-0"><p class="css-0">当你在编辑器中以字母顺序排序时，你的应用的基础组件会全部列在一起，这样更容易识别。</p></li><li class="css-0"><p class="css-0">因为组件名应该始终是多个单词，所以这样做可以避免你在包裹简单组件时随意选择前缀 (比如 <code class="css-0">MyButton</code>、<code class="css-0">VueButton</code>)。</p></li><li class="css-0"><p class="css-0">因为这些组件会被频繁使用，所以你可能想把它们放到全局而不是在各处分别导入它们。使用相同的前缀可以让 webpack 这样工作：</p><pre class="css-0"><code class="language-js css-0">var requireComponent = require.context(&quot;./src&quot;, true, /Base[A-Z]\w+\.(vue|js)$/)
requireComponent.keys().forEach(function (fileName) {
  var baseComponentConfig = requireComponent(fileName)
  baseComponentConfig = baseComponentConfig.default || baseComponentConfig
  var baseComponentName = baseComponentConfig.name || (
    fileName
      .replace(/^.+\//, &#x27;&#x27;)
      .replace(/\.\w+$/, &#x27;&#x27;)
  )
  Vue.component(baseComponentName, baseComponentConfig)
})
</code></pre></li></ul><h4 class="css-0">反例</h4><pre class="css-0"><code class="css-0">components/
|- MyButton.vue
|- VueTable.vue
|- Icon.vue
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="css-0">components/
|- BaseButton.vue
|- BaseTable.vue
|- BaseIcon.vue
</code></pre><pre class="css-0"><code class="css-0">components/
|- AppButton.vue
|- AppTable.vue
|- AppIcon.vue
</code></pre><pre class="css-0"><code class="css-0">components/
|- VButton.vue
|- VTable.vue
|- VIcon.vue
</code></pre><h3 class="css-0">单例组件名<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">只应该拥有单个活跃实例的组件应该以 <code class="css-0">The</code> 前缀命名，以示其唯一性。</strong></p><p class="css-0">这不意味着组件只可用于一个单页面，而是<em class="css-0">每个页面</em>只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，<em class="css-0">只是目前</em>在每个页面里只使用一次。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="css-0">components/
|- Heading.vue
|- MySidebar.vue
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="css-0">components/
|- TheHeading.vue
|- TheSidebar.vue
</code></pre><h3 class="css-0">紧密耦合的组件名<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong></p><p class="css-0">如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p><h4 class="css-0">详解</h4><p class="css-0">你可以试着通过在其父组件命名的目录中嵌套子组件以解决这个问题。比如：</p><pre class="css-0"><code class="css-0">components/
|- TodoList/
   |- Item/
      |- index.vue
      |- Button.vue
   |- index.vue
</code></pre><p class="css-0">或：</p><pre class="css-0"><code class="css-0">components/
|- TodoList/
   |- Item/
      |- Button.vue
   |- Item.vue
|- TodoList.vue
</code></pre><p class="css-0">但是这种方式并不推荐，因为这会导致：</p><ul class="css-0"><li class="css-0">许多文件的名字相同，使得在编辑器中快速切换文件变得困难。</li><li class="css-0">过多嵌套的子目录增加了在编辑器侧边栏中浏览组件所花的时间。</li></ul><h4 class="css-0">反例</h4><pre class="css-0"><code class="css-0">components/
|- TodoList.vue
|- TodoItem.vue
|- TodoButton.vue
</code></pre><pre class="css-0"><code class="css-0">components/
|- SearchSidebar.vue
|- NavigationForSearchSidebar.vue
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="css-0">components/
|- TodoList.vue
|- TodoListItem.vue
|- TodoListItemButton.vue
</code></pre><pre class="css-0"><code class="css-0">components/
|- SearchSidebar.vue
|- SearchSidebarNavigation.vue
</code></pre><h3 class="css-0">组件名中的单词顺序<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong></p><h4 class="css-0">详解</h4><p class="css-0">你可能会疑惑：</p><blockquote class="css-0"><p class="css-0">“为什么我们给组件命名时不多遵从自然语言呢？”</p></blockquote><p class="css-0">在自然的英文里，形容词和其它描述语通常都出现在名词之前，否则需要使用连接词。比如：</p><ul class="css-0"><li class="css-0">Coffee <em class="css-0">with</em> milk</li><li class="css-0">Soup <em class="css-0">of the</em> day</li><li class="css-0">Visitor <em class="css-0">to the</em> museum</li></ul><p class="css-0">如果你愿意，你完全可以在组件名里包含这些连接词，但是单词的顺序很重要。</p><p class="css-0">同样要注意<strong class="css-0">在你的应用中所谓的“高级别”是跟语境有关的</strong>。比如对于一个带搜索表单的应用来说，它可能包含这样的组件：</p><pre class="css-0"><code class="css-0">components/
|- ClearSearchButton.vue
|- ExcludeFromSearchInput.vue
|- LaunchOnStartupCheckbox.vue
|- RunSearchButton.vue
|- SearchInput.vue
|- TermsCheckbox.vue
</code></pre><p class="css-0">你可能注意到了，我们很难看出来哪些组件是针对搜索的。现在我们来根据规则给组件重新命名：</p><pre class="css-0"><code class="css-0">components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputExcludeGlob.vue
|- SearchInputQuery.vue
|- SettingsCheckboxLaunchOnStartup.vue
|- SettingsCheckboxTerms.vue
</code></pre><p class="css-0">因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。</p><p class="css-0">你可能想换成多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为：</p><ul class="css-0"><li class="css-0">在多级目录间找来找去，要比在单个 <code class="css-0">components</code> 目录下滚动查找要花费更多的精力。</li><li class="css-0">存在组件重名 (比如存在多个 <code class="css-0">ButtonDelete</code> 组件) 的时候在编辑器里更难快速定位。</li><li class="css-0">让重构变得更难，因为为一个移动了的组件更新相关引用时，查找/替换通常并不高效。</li></ul><h4 class="css-0">反例</h4><pre class="css-0"><code class="css-0">components/
|- ClearSearchButton.vue
|- ExcludeFromSearchInput.vue
|- LaunchOnStartupCheckbox.vue
|- RunSearchButton.vue
|- SearchInput.vue
|- TermsCheckbox.vue
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="css-0">components/
|- SearchButtonClear.vue
|- SearchButtonRun.vue
|- SearchInputQuery.vue
|- SearchInputExcludeGlob.vue
|- SettingsCheckboxTerms.vue
|- SettingsCheckboxLaunchOnStartup.vue
</code></pre><h3 class="css-0">自闭合组件<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">在<a href="../guide/single-file-components.html" class="css-0">单文件组件</a>、字符串模板和 <a href="../guide/render-function.html#JSX" class="css-0">JSX</a> 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p><p class="css-0">自闭合组件表示它们不仅没有内容，而且<strong class="css-0">刻意</strong>没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。</p><p class="css-0">不幸的是，HTML 并不支持自闭合的自定义元素——只有<a href="https://www.w3.org/TR/html/syntax.html#void-elements" class="css-0">官方的“空”元素</a>。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;
&lt;MyComponent&gt;&lt;/MyComponent&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- 在 DOM 模板中 --&gt;
&lt;my-component/&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;
&lt;MyComponent/&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- 在 DOM 模板中 --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
</code></pre><h3 class="css-0">模板中的组件名大小写<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">对于绝大多数项目来说，在<a href="../guide/single-file-components.html" class="css-0">单文件组件</a>和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</strong></p><p class="css-0">PascalCase 相比 kebab-case 有一些优势：</p><ul class="css-0"><li class="css-0">编辑器可以在模板里自动补全组件名，因为 PascalCase 同样适用于 JavaScript。</li><li class="css-0"><code class="css-0">&lt;MyComponent&gt;</code> 视觉上比 <code class="css-0">&lt;my-component&gt;</code> 更能够和单个单词的 HTML 元素区别开来，因为前者的不同之处有两个大写字母，后者只有一个横线。</li><li class="css-0">如果你在模板中使用任何非 Vue 的自定义元素，比如一个 Web Component，PascalCase 确保了你的 Vue 组件在视觉上仍然是易识别的。</li></ul><p class="css-0">不幸的是，由于 HTML 是大小写不敏感的，在 DOM 模板中必须仍使用 kebab-case。</p><p class="css-0">还请注意，如果你已经是 kebab-case 的重度用户，那么与 HTML 保持一致的命名约定且在多个项目中保持相同的大小写规则就可能比上述优势更为重要了。在这些情况下，<strong class="css-0">在所有的地方都使用 kebab-case 同样是可以接受的。</strong></p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;!-- 在单文件组件和字符串模板中 --&gt;
&lt;mycomponent/&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- 在单文件组件和字符串模板中 --&gt;
&lt;myComponent/&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- 在 DOM 模板中 --&gt;
&lt;MyComponent&gt;&lt;/MyComponent&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;!-- 在单文件组件和字符串模板中 --&gt;
&lt;MyComponent/&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- 在 DOM 模板中 --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
</code></pre><p class="css-0">或者</p><pre class="css-0"><code class="language-html css-0">&lt;!-- 在所有地方 --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
</code></pre><h3 class="css-0">JS/JSX 中的组件名大小写<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">JS/<a href="../guide/render-function.html#JSX" class="css-0">JSX</a> 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 <code class="css-0">Vue.component</code> 进行全局组件注册时，可以使用 kebab-case 字符串。</strong></p><h4 class="css-0">详解</h4><p class="css-0">在 JavaScript 中，PascalCase 是类和构造函数 (本质上任何可以产生多份不同实例的东西) 的命名约定。Vue 组件也有多份实例，所以同样使用 PascalCase 是有意义的。额外的好处是，在 JSX (和模板) 里使用 PascalCase 使得代码的读者更容易分辨 Vue 组件和 HTML 元素。</p><p class="css-0">然而，对于<strong class="css-0">只</strong>通过 <code class="css-0">Vue.component</code> 定义全局组件的应用来说，我们推荐 kebab-case 作为替代。原因是：</p><ul class="css-0"><li class="css-0">全局组件很少被 JavaScript 引用，所以遵守 JavaScript 的命名约定意义不大。</li><li class="css-0">这些应用往往包含许多 DOM 内的模板，这种情况下是<a href="#%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90" class="css-0"><strong class="css-0">必须</strong>使用 kebab-case</a> 的。</li></ul><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;myComponent&#x27;, {
  // ...
})
</code></pre><pre class="css-0"><code class="language-js css-0">import myComponent from &#x27;./MyComponent.vue&#x27;
</code></pre><pre class="css-0"><code class="language-js css-0">export default {
  name: &#x27;myComponent&#x27;,
  // ...
}
</code></pre><pre class="css-0"><code class="language-js css-0">export default {
  name: &#x27;my-component&#x27;,
  // ...
}
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;MyComponent&#x27;, {
  // ...
})
</code></pre><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;my-component&#x27;, {
  // ...
})
</code></pre><pre class="css-0"><code class="language-js css-0">import MyComponent from &#x27;./MyComponent.vue&#x27;
</code></pre><pre class="css-0"><code class="language-js css-0">export default {
  name: &#x27;MyComponent&#x27;,
  // ...
}
</code></pre><h3 class="css-0">完整单词的组件名<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">组件名应该倾向于完整单词而不是缩写。</strong></p><p class="css-0">编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="css-0">components/
|- SdSettings.vue
|- UProfOpts.vue
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="css-0">components/
|- StudentDashboardSettings.vue
|- UserProfileOptions.vue
</code></pre><h3 class="css-0">Prop 名大小写<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 <a href="../guide/render-function.html#JSX" class="css-0">JSX</a> 中应该始终使用 kebab-case。</strong></p><p class="css-0">我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">props: {
  &#x27;greeting-text&#x27;: String
}
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">props: {
  greetingText: String
}
</code></pre><h3 class="css-0">多个 attribute 的元素<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p><p class="css-0">在 JavaScript 中，用多行分隔对象的多个 property 是很常见的最佳实践，因为这样更易读。模板和 <a href="../guide/render-function.html#JSX" class="css-0">JSX</a> 值得我们做相同的考虑。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;img src=&quot;https://vuejs.org/images/logo.png&quot; alt=&quot;Vue Logo&quot;&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;img
  src=&quot;https://vuejs.org/images/logo.png&quot;
  alt=&quot;Vue Logo&quot;
&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;MyComponent
  foo=&quot;a&quot;
  bar=&quot;b&quot;
  baz=&quot;c&quot;
/&gt;
</code></pre><h3 class="css-0">模板中简单的表达式<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p><p class="css-0">复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<em class="css-0">是什么</em>，而非<em class="css-0">如何</em>计算那个值。而且计算属性和方法使得代码可以重用。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">{{
  fullName.split(&#x27; &#x27;).map(function (word) {
    return word[0].toUpperCase() + word.slice(1)
  }).join(&#x27; &#x27;)
}}
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;!-- 在模板中 --&gt;
{{ normalizedFullName }}
</code></pre><pre class="css-0"><code class="language-js css-0">// 复杂表达式已经移入一个计算属性
computed: {
  normalizedFullName: function () {
    return this.fullName.split(&#x27; &#x27;).map(function (word) {
      return word[0].toUpperCase() + word.slice(1)
    }).join(&#x27; &#x27;)
  }
}
</code></pre><h3 class="css-0">简单的计算属性<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">应该把复杂计算属性分割为尽可能多的更简单的 property。</strong></p><h4 class="css-0">详解</h4><p class="css-0">更简单、命名得当的计算属性是这样的：</p><ul class="css-0"><li class="css-0"><p class="css-0"><strong class="css-0">易于测试</strong></p><p class="css-0">当每个计算属性都包含一个非常简单且很少依赖的表达式时，撰写测试以确保其正确工作就会更加容易。</p></li><li class="css-0"><p class="css-0"><strong class="css-0">易于阅读</strong></p><p class="css-0">简化计算属性要求你为每一个值都起一个描述性的名称，即便它不可复用。这使得其他开发者 (以及未来的你) 更容易专注在他们关心的代码上并搞清楚发生了什么。</p></li><li class="css-0"><p class="css-0"><strong class="css-0">更好的“拥抱变化”</strong></p><p class="css-0">任何能够命名的值都可能用在视图上。举个例子，我们可能打算展示一个信息，告诉用户他们存了多少钱；也可能打算计算税费，但是可能会分开展现，而不是作为总价的一部分。</p><p class="css-0">小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p></li></ul><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">computed: {
  price: function () {
    var basePrice = this.manufactureCost / (1 - this.profitMargin)
    return (
      basePrice -
      basePrice * (this.discountPercent || 0)
    )
  }
}
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">computed: {
  basePrice: function () {
    return this.manufactureCost / (1 - this.profitMargin)
  },
  discount: function () {
    return this.basePrice * (this.discountPercent || 0)
  },
  finalPrice: function () {
    return this.basePrice - this.discount
  }
}
</code></pre><h3 class="css-0">带引号的 attribute 值<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">非空 HTML attribute 值应该始终带引号 (单引号或双引号，以 JS 中未使用的为准)。</strong></p><p class="css-0">在 HTML 中不带空格的 attribute 值是可以没有引号的，但这鼓励了大家在特征值里<em class="css-0">不写</em>空格，导致可读性变差。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;input type=text&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;AppSidebar :style={width:sidebarWidth+&#x27;px&#x27;}&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;input type=&quot;text&quot;&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;AppSidebar :style=&quot;{ width: sidebarWidth + &#x27;px&#x27; }&quot;&gt;
</code></pre><h3 class="css-0">指令缩写<sup data-p="b">强烈推荐</sup></h3><p class="css-0"><strong class="css-0">指令缩写 (用 <code class="css-0">:</code> 表示 <code class="css-0">v-bind:</code>、用 <code class="css-0">@</code> 表示 <code class="css-0">v-on:</code> 和用 <code class="css-0">#</code> 表示 <code class="css-0">v-slot:</code>) 应该要么都用要么都不用。</strong></p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;input
  v-bind:value=&quot;newTodoText&quot;
  :placeholder=&quot;newTodoInstructions&quot;
&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;input
  v-on:input=&quot;onInput&quot;
  @focus=&quot;onFocus&quot;
&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;template v-slot:header&gt;
  &lt;h1&gt;Here might be a page title&lt;/h1&gt;
&lt;/template&gt;

&lt;template #footer&gt;
  &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;
&lt;/template&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;input
  :value=&quot;newTodoText&quot;
  :placeholder=&quot;newTodoInstructions&quot;
&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;input
  v-bind:value=&quot;newTodoText&quot;
  v-bind:placeholder=&quot;newTodoInstructions&quot;
&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;input
  @input=&quot;onInput&quot;
  @focus=&quot;onFocus&quot;
&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;input
  v-on:input=&quot;onInput&quot;
  v-on:focus=&quot;onFocus&quot;
&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;template v-slot:header&gt;
  &lt;h1&gt;Here might be a page title&lt;/h1&gt;
&lt;/template&gt;

&lt;template v-slot:footer&gt;
  &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;
&lt;/template&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;template #header&gt;
  &lt;h1&gt;Here might be a page title&lt;/h1&gt;
&lt;/template&gt;

&lt;template #footer&gt;
  &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;
&lt;/template&gt;
</code></pre><h2 class="css-0">优先级 C 的规则：推荐 (将选择和认知成本最小化)</h2><h3 class="css-0">组件/实例的选项的顺序<sup data-p="c">推荐</sup></h3><p class="css-0"><strong class="css-0">组件/实例的选项应该有统一的顺序。</strong></p><p class="css-0">这是我们推荐的组件选项默认顺序。它们被划分为几大类，所以你也能知道从插件里添加的新 property 应该放到哪里。</p><ol class="css-0"><li class="css-0"><strong class="css-0">副作用</strong> (触发组件外的影响)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">el</code></li></ul><ol start="2" class="css-0"><li class="css-0"><strong class="css-0">全局感知</strong> (要求组件以外的知识)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">name</code></li><li class="css-0"><code class="css-0">parent</code></li></ul><ol start="3" class="css-0"><li class="css-0"><strong class="css-0">组件类型</strong> (更改组件的类型)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">functional</code></li></ul><ol start="4" class="css-0"><li class="css-0"><strong class="css-0">模板修改器</strong> (改变模板的编译方式)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">delimiters</code></li><li class="css-0"><code class="css-0">comments</code></li></ul><ol start="5" class="css-0"><li class="css-0"><strong class="css-0">模板依赖</strong> (模板内使用的资源)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">components</code></li><li class="css-0"><code class="css-0">directives</code></li><li class="css-0"><code class="css-0">filters</code></li></ul><ol start="6" class="css-0"><li class="css-0"><strong class="css-0">组合</strong> (向选项里合并 property)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">extends</code></li><li class="css-0"><code class="css-0">mixins</code></li></ul><ol start="7" class="css-0"><li class="css-0"><strong class="css-0">接口</strong> (组件的接口)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">inheritAttrs</code></li><li class="css-0"><code class="css-0">model</code></li><li class="css-0"><code class="css-0">props</code>/<code class="css-0">propsData</code></li></ul><ol start="8" class="css-0"><li class="css-0"><strong class="css-0">本地状态</strong> (本地的响应式 property)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">data</code></li><li class="css-0"><code class="css-0">computed</code></li></ul><ol start="9" class="css-0"><li class="css-0"><strong class="css-0">事件</strong> (通过响应式事件触发的回调)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">watch</code></li><li class="css-0">生命周期钩子 (按照它们被调用的顺序)<ul class="css-0"><li class="css-0"><code class="css-0">beforeCreate</code></li><li class="css-0"><code class="css-0">created</code></li><li class="css-0"><code class="css-0">beforeMount</code></li><li class="css-0"><code class="css-0">mounted</code></li><li class="css-0"><code class="css-0">beforeUpdate</code></li><li class="css-0"><code class="css-0">updated</code></li><li class="css-0"><code class="css-0">activated</code></li><li class="css-0"><code class="css-0">deactivated</code></li><li class="css-0"><code class="css-0">beforeDestroy</code></li><li class="css-0"><code class="css-0">destroyed</code></li></ul></li></ul><ol start="10" class="css-0"><li class="css-0"><strong class="css-0">非响应式的 property</strong> (不依赖响应系统的实例 property)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">methods</code></li></ul><ol start="11" class="css-0"><li class="css-0"><strong class="css-0">渲染</strong> (组件输出的声明式描述)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">template</code>/<code class="css-0">render</code></li><li class="css-0"><code class="css-0">renderError</code></li></ul><h3 class="css-0">元素 attribute 的顺序<sup data-p="c">推荐</sup></h3><p class="css-0"><strong class="css-0">元素 (包括组件) 的 attribute 应该有统一的顺序。</strong></p><p class="css-0">这是我们为组件选项推荐的默认顺序。它们被划分为几大类，所以你也能知道新添加的自定义 attribute 和指令应该放到哪里。</p><ol class="css-0"><li class="css-0"><strong class="css-0">定义</strong> (提供组件的选项)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">is</code></li></ul><ol start="2" class="css-0"><li class="css-0"><strong class="css-0">列表渲染</strong> (创建多个变化的相同元素)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">v-for</code></li></ul><ol start="3" class="css-0"><li class="css-0"><strong class="css-0">条件渲染</strong> (元素是否渲染/显示)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">v-if</code></li><li class="css-0"><code class="css-0">v-else-if</code></li><li class="css-0"><code class="css-0">v-else</code></li><li class="css-0"><code class="css-0">v-show</code></li><li class="css-0"><code class="css-0">v-cloak</code></li></ul><ol start="4" class="css-0"><li class="css-0"><strong class="css-0">渲染方式</strong> (改变元素的渲染方式)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">v-pre</code></li><li class="css-0"><code class="css-0">v-once</code></li></ul><ol start="5" class="css-0"><li class="css-0"><strong class="css-0">全局感知</strong> (需要超越组件的知识)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">id</code></li></ul><ol start="6" class="css-0"><li class="css-0"><strong class="css-0">唯一的 attribute</strong> (需要唯一值的 attribute)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">ref</code></li><li class="css-0"><code class="css-0">key</code></li></ul><ol start="7" class="css-0"><li class="css-0"><strong class="css-0">双向绑定</strong> (把绑定和事件结合起来)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">v-model</code></li></ul><ol start="8" class="css-0"><li class="css-0"><p class="css-0"><strong class="css-0">其它 attribute</strong> (所有普通的绑定或未绑定的 attribute)</p></li><li class="css-0"><p class="css-0"><strong class="css-0">事件</strong> (组件事件监听器)</p></li></ol><ul class="css-0"><li class="css-0"><code class="css-0">v-on</code></li></ul><ol start="10" class="css-0"><li class="css-0"><strong class="css-0">内容</strong> (覆写元素的内容)</li></ol><ul class="css-0"><li class="css-0"><code class="css-0">v-html</code></li><li class="css-0"><code class="css-0">v-text</code></li></ul><h3 class="css-0">组件/实例选项中的空行<sup data-p="c">推荐</sup></h3><p class="css-0"><strong class="css-0">你可能想在多个 property 之间增加一个空行，特别是在这些选项一屏放不下，需要滚动才能都看到的时候。</strong></p><p class="css-0">当你的组件开始觉得密集或难以阅读时，在多个 property 之间添加空行可以让其变得容易。在一些诸如 Vim 的编辑器里，这样格式化后的选项还能通过键盘被快速导航。</p><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">props: {
  value: {
    type: String,
    required: true
  },

  focused: {
    type: Boolean,
    default: false
  },

  label: String,
  icon: String
},

computed: {
  formattedValue: function () {
    // ...
  },

  inputClasses: function () {
    // ...
  }
}
</code></pre><pre class="css-0"><code class="language-js css-0">// 没有空行在组件易于阅读和导航时也没问题。
props: {
  value: {
    type: String,
    required: true
  },
  focused: {
    type: Boolean,
    default: false
  },
  label: String,
  icon: String
},
computed: {
  formattedValue: function () {
    // ...
  },
  inputClasses: function () {
    // ...
  }
}
</code></pre><h3 class="css-0">单文件组件的顶级元素的顺序<sup data-p="c">推荐</sup></h3><p class="css-0"><strong class="css-0"><a href="../guide/single-file-components.html" class="css-0">单文件组件</a>应该总是让 <code class="css-0">&lt;script&gt;</code>、<code class="css-0">&lt;template&gt;</code> 和 <code class="css-0">&lt;style&gt;</code> 标签的顺序保持一致。且 <code class="css-0">&lt;style&gt;</code> 要放在最后，因为另外两个标签至少要有一个。</strong></p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;style&gt;/* ... */&lt;/style&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;template&gt;...&lt;/template&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- ComponentA.vue --&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;template&gt;...&lt;/template&gt;
&lt;style&gt;/* ... */&lt;/style&gt;

&lt;!-- ComponentB.vue --&gt;
&lt;template&gt;...&lt;/template&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;style&gt;/* ... */&lt;/style&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;!-- ComponentA.vue --&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;template&gt;...&lt;/template&gt;
&lt;style&gt;/* ... */&lt;/style&gt;

&lt;!-- ComponentB.vue --&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;template&gt;...&lt;/template&gt;
&lt;style&gt;/* ... */&lt;/style&gt;
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- ComponentA.vue --&gt;
&lt;template&gt;...&lt;/template&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;style&gt;/* ... */&lt;/style&gt;

&lt;!-- ComponentB.vue --&gt;
&lt;template&gt;...&lt;/template&gt;
&lt;script&gt;/* ... */&lt;/script&gt;
&lt;style&gt;/* ... */&lt;/style&gt;
</code></pre><h2 class="css-0">优先级 D 的规则：谨慎使用 (有潜在危险的模式)</h2><h3 class="css-0">没有在 <code class="css-0">v-if</code>/<code class="css-0">v-else-if</code>/<code class="css-0">v-else</code> 中使用 <code class="css-0">key</code> <sup data-p="d">谨慎使用</sup></h3><p class="css-0"><strong class="css-0">如果一组 <code class="css-0">v-if</code> + <code class="css-0">v-else</code> 的元素类型相同，最好使用 <code class="css-0">key</code> (比如两个 <code class="css-0">&lt;div&gt;</code> 元素)。</strong></p><p class="css-0">默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现<a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences" class="css-0">意料之外的结果</a>。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;div v-if=&quot;error&quot;&gt;
  错误：{{ error }}
&lt;/div&gt;
&lt;div v-else&gt;
  {{ results }}
&lt;/div&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;div
  v-if=&quot;error&quot;
  key=&quot;search-status&quot;
&gt;
  错误：{{ error }}
&lt;/div&gt;
&lt;div
  v-else
  key=&quot;search-results&quot;
&gt;
  {{ results }}
&lt;/div&gt;
</code></pre><h3 class="css-0"><code class="css-0">scoped</code> 中的元素选择器<sup data-p="d">谨慎使用</sup></h3><p class="css-0"><strong class="css-0">元素选择器应该避免在 <code class="css-0">scoped</code> 中出现。</strong></p><p class="css-0">在 <code class="css-0">scoped</code> 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。</p><h4 class="css-0">详解</h4><p class="css-0">为了给样式设置作用域，Vue 会为元素添加一个独一无二的 attribute，例如 <code class="css-0">data-v-f3f3eg9</code>。然后修改选择器，使得在匹配选择器的元素中，只有带这个 attribute 才会真正生效 (比如 <code class="css-0">button[data-v-f3f3eg9]</code>)。</p><p class="css-0">问题在于大量的<a href="http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=a%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000" class="css-0">元素和 attribute 组合的选择器</a> (比如 <code class="css-0">button[data-v-f3f3eg9]</code>) 会比<a href="http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=.class%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000" class="css-0">类和 attribute 组合的选择器</a>慢，所以应该尽可能选用类选择器。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-html css-0">&lt;template&gt;
  &lt;button&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;style scoped&gt;
button {
  background-color: red;
}
&lt;/style&gt;
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-html css-0">&lt;template&gt;
  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.btn-close {
  background-color: red;
}
&lt;/style&gt;
</code></pre><h3 class="css-0">隐性的父子组件通信<sup data-p="d">谨慎使用</sup></h3><p class="css-0"><strong class="css-0">应该优先通过 prop 和事件进行父子组件之间的通信，而不是 <code class="css-0">this.$parent</code> 或变更 prop。</strong></p><p class="css-0">一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 <code class="css-0">this.$parent</code> 能够简化两个深度耦合的组件。</p><p class="css-0">问题在于，这种做法在很多<em class="css-0">简单</em>的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;TodoItem&#x27;, {
  props: {
    todo: {
      type: Object,
      required: true
    }
  },
  template: &#x27;&lt;input v-model=&quot;todo.text&quot;&gt;&#x27;
})
</code></pre><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;TodoItem&#x27;, {
  props: {
    todo: {
      type: Object,
      required: true
    }
  },
  methods: {
    removeTodo () {
      var vm = this
      vm.$parent.todos = vm.$parent.todos.filter(function (todo) {
        return todo.id !== vm.todo.id
      })
    }
  },
  template: `
    &lt;span&gt;
      {{ todo.text }}
      &lt;button @click=&quot;removeTodo&quot;&gt;
        X
      &lt;/button&gt;
    &lt;/span&gt;
  `
})
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;TodoItem&#x27;, {
  props: {
    todo: {
      type: Object,
      required: true
    }
  },
  template: `
    &lt;input
      :value=&quot;todo.text&quot;
      @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;
    &gt;
  `
})
</code></pre><pre class="css-0"><code class="language-js css-0">Vue.component(&#x27;TodoItem&#x27;, {
  props: {
    todo: {
      type: Object,
      required: true
    }
  },
  template: `
    &lt;span&gt;
      {{ todo.text }}
      &lt;button @click=&quot;$emit(&#x27;delete&#x27;)&quot;&gt;
        X
      &lt;/button&gt;
    &lt;/span&gt;
  `
})
</code></pre><h3 class="css-0">非 Flux 的全局状态管理<sup data-p="d">谨慎使用</sup></h3><p class="css-0"><strong class="css-0">应该优先通过 <a href="https://github.com/vuejs/vuex" class="css-0">Vuex</a> 管理全局状态，而不是通过 <code class="css-0">this.$root</code> 或一个全局事件总线。</strong></p><p class="css-0">通过 <code class="css-0">this.$root</code> 和/或<a href="../guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" class="css-0">全局事件总线</a>管理状态在很多简单的情况下都是很方便的，但是并不适用于绝大多数的应用。</p><p class="css-0">Vuex 是 Vue 的<a href="../guide/state-management.html#%E7%B1%BB-Flux-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0" class="css-0">官方类 flux 实现</a>，其提供的不仅是一个管理状态的中心区域，还是组织、追踪和调试状态变更的好工具。它很好地集成在了 Vue 生态系统之中 (包括完整的 <a href="../guide/installation.html#Vue-Devtools" class="css-0">Vue DevTools</a> 支持)。</p><h4 class="css-0">反例</h4><pre class="css-0"><code class="language-js css-0">// main.js
new Vue({
  data: {
    todos: []
  },
  created: function () {
    this.$on(&#x27;remove-todo&#x27;, this.removeTodo)
  },
  methods: {
    removeTodo: function (todo) {
      var todoIdToRemove = todo.id
      this.todos = this.todos.filter(function (todo) {
        return todo.id !== todoIdToRemove
      })
    }
  }
})
</code></pre><h4 class="css-0">好例子</h4><pre class="css-0"><code class="language-js css-0">// store/modules/todos.js
export default {
  state: {
    list: []
  },
  mutations: {
    REMOVE_TODO (state, todoId) {
      state.list = state.list.filter(todo =&gt; todo.id !== todoId)
    }
  },
  actions: {
    removeTodo ({ commit, state }, todo) {
      commit(&#x27;REMOVE_TODO&#x27;, todo.id)
    }
  }
}
</code></pre><pre class="css-0"><code class="language-html css-0">&lt;!-- TodoItem.vue --&gt;
&lt;template&gt;
  &lt;span&gt;
    {{ todo.text }}
    &lt;button @click=&quot;removeTodo(todo)&quot;&gt;
      X
    &lt;/button&gt;
  &lt;/span&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapActions } from &#x27;vuex&#x27;

export default {
  props: {
    todo: {
      type: Object,
      required: true
    }
  },
  methods: mapActions([&#x27;removeTodo&#x27;])
}
&lt;/script&gt;
</code></pre></main></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/front-guide/language/vue-guide/";window.___webpackCompilationHash="5e1abc7217b883e46c4e";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-fb56006874e3911784ed.js"],"app":["/app-5ff64c5c6731c3d5b165.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-c984588366e36595e3f0.js"],"component---src-pages-blog-page-tsx":["/component---src-pages-blog-page-tsx-6c628ecc27a01ed01733.js"],"component---src-pages-front-end-page-tsx":["/component---src-pages-front-end-page-tsx-c02bb3ccd696b9175493.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-cc0e6606af768ec19edc.js"],"component---src-pages-mdx-slug-tsx":["/component---src-pages-mdx-slug-tsx-e6b9a5a5ab118c518437.js"]};/*]]>*/</script><script src="/polyfill-fb56006874e3911784ed.js" nomodule=""></script><script src="/component---src-pages-mdx-slug-tsx-e6b9a5a5ab118c518437.js" async=""></script><script src="/42c9f84f9645ed5f761b4c6678255cf01342391e-664e7f9e279843ee0ff6.js" async=""></script><script src="/app-5ff64c5c6731c3d5b165.js" async=""></script><script src="/framework-40f550404eff6143517a.js" async=""></script><script src="/webpack-runtime-a8b117a0c06915913bd8.js" async=""></script></body></html>